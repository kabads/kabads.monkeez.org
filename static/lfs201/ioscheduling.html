<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ioscheduling</title>
<!-- 2015-05-28 Thu 16:18 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ioscheduling</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. I/O Scheduling</a>
<ul>
<li><a href="#sec-1-1">1.1. Objectives</a>
<ul>
<li><a href="#sec-1-1-1">1.1.1. Explain the importance of I/O scheduling and describe the conflicting requirements that need to be satisfied</a></li>
<li><a href="#sec-1-1-2">1.1.2. Delineate and contrast the options available under Linux</a></li>
<li><a href="#sec-1-1-3">1.1.3. Understand how the <b>CFQ</b> (Completely Fair Queue) and <b>Deadline</b> algorithms work.</a></li>
</ul>
</li>
<li><a href="#sec-1-2">1.2. I/O Scheduling</a></li>
<li><a href="#sec-1-3">1.3. I/O Scheduler Choices</a></li>
<li><a href="#sec-1-4">1.4. I/O Scheduling and SSD Devices</a></li>
<li><a href="#sec-1-5">1.5. Tunables and Switching The I/O Scheduler at Run Time</a></li>
<li><a href="#sec-1-6">1.6. CFQ (Completely Fair Queue)</a></li>
<li><a href="#sec-1-7">1.7. CFQ Tunables</a></li>
<li><a href="#sec-1-8">1.8. Deadline scheduler</a></li>
<li><a href="#sec-1-9">1.9. Deadline Tunables</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> I/O Scheduling</h2>
<div class="outline-text-2" id="text-1">
<p>
System performace often depends very heavily on optimizing the I/O scheduling strategy. Many (often competing) factors influence behaviour; these include minimizing hardware access times, avoiding wear and tear on storage media, ensuring data integrity granting timely access to applications that need to do I/O, and being able to prioritize important tasks. Linux offers a variety of <b>I/O Schedulers</b> to choose from, each of which has tunable parameters, as well as a number of utilities for reporting on and analyzing I/O performance. 
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Objectives</h3>
<div class="outline-text-3" id="text-1-1">
</div><div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1"><span class="section-number-4">1.1.1</span> Explain the importance of I/O scheduling and describe the conflicting requirements that need to be satisfied</h4>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2"><span class="section-number-4">1.1.2</span> Delineate and contrast the options available under Linux</h4>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3"><span class="section-number-4">1.1.3</span> Understand how the <b>CFQ</b> (Completely Fair Queue) and <b>Deadline</b> algorithms work.</h4>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> I/O Scheduling</h3>
<div class="outline-text-3" id="text-1-2">
<p>
The <b>I/O scheduler</b> provides the interface between the generic block layer and low-level physical device drivers. Both the VM (Virtual Memory) and VFS (virtual file system) layers submit I/O requests to block devices; it is the job of the I/O scheduling layer to prioritize and order these requests before they are given to the block devices. 
Any I/O scheduling algorithm has to satisfy certain (sometimes conflicting) requirements:
</p>
<ul class="org-ul">
<li>Hardware access times should be minimized; i.e. requests should be ordered according to physical location on the disk. This leads to an <b>elevator</b> scheme where requests are inserted in the pending queue in physical order. 
</li>
<li>Requests should be merged to the extent possible to get as big a contiguous region as possible, which also minimizes disk access time.
</li>
<li>Requests should be satisfied with as low a latency as is feasible; indeed in some cases determinism (in the sense of deadlines) may be important.
</li>
<li>Write operations can usually wait to migrate from caches to disk without stalling processes. Read operations, however, almost always require a process to wait for completion before proceeding further. Favouring reads over writes leads to better parallelism and system responsiveness.
</li>
<li>Processes should take the I/O bandwidth in a fair, or at least consciously prioritized fashion; even if it means some overall performance slowdown of the I/O layer, process throughput should not suffer inordinately.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> I/O Scheduler Choices</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Since these demands can be conflicting, different I/O schedulers may be appropriate for different workloads; e.g. a large database server vs. a desktop system. Furthermore, different hardware may mandate different strategy. In order to provide flexibility, the linux kernel has an object oriented scheme, in which pointers to the various needed functions are supplied in a data structure, the particular one of which can be selected at boot on the kernel command line as in: 
linux &#x2026; elevator=[cfq|deadline|noop]
At least one of the I/O scheduling algorithms must be compiled in to the kernel. The current choices are:
</p>
<ul class="org-ul">
<li><b>Completely Fair Queueing (CFQ)</b>
</li>
<li><b>Deadline scheduling</b>
</li>
<li><b>noop</b> (A simple scheme)
</li>
</ul>
<p>
The default choice is a compile configuration option; modern distributions choose either <b>CFQ</b> or <b>Deadline</b>. 
</p>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> I/O Scheduling and SSD Devices</h3>
<div class="outline-text-3" id="text-1-4">
<p>
The gradual introduction of <b>SSD</b> (Solid State Drive) devices which use flash memory to emulate hard disks has important implications for I/O scheduling. 
Such devices do not require an elevator scheme and benefit from <b>wear leveling</b> to spread I/O over the devices which have limited write/erase cycles.
One can examine /sys/block/&lt;device&gt;/queue/rotational to see whether or not the device is an <b>SSD</b> or not, as in:
$ cat /sys/block/sda/queue/rotational
1
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5"><span class="section-number-3">1.5</span> Tunables and Switching The I/O Scheduler at Run Time</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Each of the I/O schedulers exposes parameters which can be used to tune behaviour at run time. The parameters are accessed through the pseudo-filesystem mounted at /sys.
In addition, it is possible to use different I/O schedulers for different devices. The choice can be made easily through the command line. For example:
$ cat /sys/block/sda/queue/scheduler
noop deadline [cfq]
$ echo noop &gt; /sys/block/sda/queue/scheduler
$ cat /sys/block/sda/queue/scheduler
[noop] deadline cfq
The actual tunables vary according to the particular I/O scheduler, and can be found under:
/sys/block/&lt;device&gt;/queue/iosched
For a disk using <b>CFQ</b>:
</p>

<p>
$ ls -l /sys/block/sda/queue/iosched
</p>

<p>
total 0
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 back<sub>seek</sub><sub>max</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 back<sub>seek</sub><sub>penalty</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 fifo<sub>expire</sub><sub>async</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 fifo<sub>expire</sub><sub>sync</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 group<sub>idle</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 low<sub>latency</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 quantum
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 slice<sub>async</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 slice<sub>async</sub><sub>rq</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 slice<sub>idle</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 slice<sub>sync</sub>
</p>

<p>
-rw-r&#x2013;r&#x2013; 1 root root 4096 Sep 11 11:15 target<sub>latency</sub>
We'll discuss some of these parameters shortly. 
</p>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6"><span class="section-number-3">1.6</span> CFQ (Completely Fair Queue)</h3>
<div class="outline-text-3" id="text-1-6">
<p>
The <b>CFQ</b> (completely fair queue) method has the goal of spreading the I/O bandwidth among all processes submitting requests. 
Theoretically each process has its own I/O queue, which works together with a dispatch queue which receives the actual requests on the way to the device. In actual practice, the number of queues is fixed (at 64) and a hash process based on the process ID is used to select a queue when a request is submitted. 
Dequeuing of requests is done <b>round robin</b> style on all the queues, each one of which works in <b>FIFO</b> (first in first out) order. Thus the work is spread out. To avoid excessive seeking operations, an entire round is selected, and then sorted into the dispatch queue before actual I/O requests are issued to the device. 
</p>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7"><span class="section-number-3">1.7</span> CFQ Tunables</h3>
<div class="outline-text-3" id="text-1-7">
<p>
In the examples below, the parameter <b>HZ</b> is a kernel-configured quantity, that corresponds to the number of <b>jiffies</b> per second, which the kernel uses as a course measure of time. Without getting into detail, let us just point out that time units <b>HZ/2</b> is 0.5 seconds and <b>5 * HZ</b> is 5 seconds etc. 
</p>
<ul class="org-ul">
<li><b>quantum</b>: Maximum queue lenght in one round of service (Default = 4);
</li>
<li><b>queued</b>: Minimum request allocation per queue (Default = 8);
</li>
<li><b>fifo<sub>expire</sub><sub>sync</sub></b>: <b>FIFO</b> timeout for sync requests (Default = <b>HZ/2</b>);
</li>
<li><b>fifo<sub>expire</sub><sub>async</sub></b>: <b>FIFO</b> timeout for async requests (Default = 5 * HZ);
</li>
<li><b>fifo<sub>batch</sub><sub>expire</sub></b>: Rate at which the <b>FIFO</b>'s expire (Default = HZ/8);
</li>
<li><b>back<sub>seek</sub><sub>max</sub></b>: Maximum backwards seek, in KB (Default = 16K);
</li>
<li><b>back<sub>seek</sub><sub>penalty</sub></b>: Penalty for a backwards seek (Default = 2).
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8"><span class="section-number-3">1.8</span> Deadline scheduler</h3>
<div class="outline-text-3" id="text-1-8">
<p>
The <b>Deadline I/O</b> scheduler aggressively reorders requests with the simultaneous goals of improving overall performance and preventing large latencies for individual requests; i.e. limiting starvation. 
With each and every request the kernel associates a <b>deadline</b>. Read requests get higher priority than write requests. 
Five separate <b>I/O</b> queues are maintained:
</p>
<ul class="org-ul">
<li>Two sorted lists are maintained, one for reading and one for writing, and arranged by starting block.
</li>
<li>Two <b>FIFO</b> lists are maintained, again one for reading and one for writing. These lists are sorted by submission time.
</li>
<li>A fifth queue contains the requests that are to be shoveled to the device driver itself. This is called the dispatch queue. 
</li>
</ul>
<p>
Exactly how the requests are peeled off the first four queues and placed on the fifth (dispatch queue) is where the art of the algorithm is. 
</p>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9"><span class="section-number-3">1.9</span> Deadline Tunables</h3>
<div class="outline-text-3" id="text-1-9">
<p>
Here are the available tunables for the <b>Deadline</b> scheduler.
</p>
<ul class="org-ul">
<li><b>read<sub>expire</sub></b>: How long in milliseconds a read request is guaranteed to occur within (default = HZ/2 = 500);
</li>
<li><b>write<sub>expire</sub></b>: How long (in milliseconds) a write request is guaranteed to occur within (Default = 5 * HZ = 5000);
</li>
<li><b>writes<sub>starved</sub></b>: How many requests we should give preference to reads over writes (Default = 16);
</li>
<li><b>fifo<sub>batch</sub></b>: How many requests should be moved from the sorted scheduler list to the dispatch queue, when the deadlines have expired (Default = 16);
</li>
<li><b>front<sub>merges</sub></b>: Back merges are more common than front merges as a contiguous request usually continues to the next block. Setting this parameter to 0 disables front merges and can give a boost if you know they are unlikely to be needed (Default = 1).
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2015-05-28 Thu 16:18</p>
<p class="creator"><a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.5.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
